[[module.List]]
= List

Purely-functional, singly-linked lists.

[[type.List]]
== List



[source,motoko]
----
type List<T> = ?(T, List<T>)
----

[[value.nil]]
== nil

Create an empty list.

[source,motoko]
----
func nil<T>() : List<T>
----

[[value.isNil]]
== isNil

Check whether a list is empty and return true if the list is empty.

[source,motoko]
----
func isNil<T>(l : List<T>) : Bool
----

[[value.push]]
== push

Construct a list by pre-pending a value.
This function is similar to a `list.cons(item)` function.

[source,motoko]
----
func push<T>(x : T, l : List<T>) : List<T>
----

[[value.last]]
== last

Return the last element of the list, if present.

[source,motoko]
----
func last<T>(l : List<T>) : ?T
----

[[value.pop]]
== pop

Treat the list as a stack.
This function combines the `head` and (non-failing) `tail` operations into one operation.

[source,motoko]
----
func pop<T>(l : List<T>) : (?T, List<T>)
----

[[value.size]]
== size

Return the length of the list.

[source,motoko]
----
func size<T>(l : List<T>) : Nat
----

[[value.get]]
== get

Access any item in a list, zero-based.

NOTE: Indexing into a list is a linear operation, and usually an
indication that a list might not be the best data structure
to use.

[source,motoko]
----
func get<T>(l : List<T>, n : Nat) : ?T
----

[[value.reverse]]
== reverse

Reverses the list

[source,motoko]
----
func reverse<T>(l : List<T>) : List<T>
----

[[value.iterate]]
== iterate

Call the given function with each list element in turn.

This function is equivalent to the `app` function in Standard ML Basis,
and the `iter` function in OCaml.

[source,motoko]
----
func iterate<T>(l : List<T>, f : T -> ())
----

[[value.map]]
== map

Call the given function on each list element and collect the results
in a new list.

[source,motoko]
----
func map<T, S>(l : List<T>, f : T -> S) : List<S>
----

[[value.filter]]
== filter

Create a new list with only those elements of the original list for which
the given function (often called the _predicate_) returns true.

[source,motoko]
----
func filter<T>(l : List<T>, f : T -> Bool) : List<T>
----

[[value.partition]]
== partition

Create two new lists from the results of a given function (`f`).
The first list only includes the elements for which the given
function `f` returns true and the second list only includes
the elements for which the function returns false.

[source,motoko]
----
func partition<T>(l : List<T>, f : T -> Bool) : (List<T>, List<T>)
----

[[value.mapFilter]]
== mapFilter

Call the given function on each list element, and collect the non-null results
in a new list.

[source,motoko]
----
func mapFilter<T, S>(l : List<T>, f : T -> ?S) : List<S>
----

[[value.mapResult]]
== mapResult

Maps a Result-returning function over a List and returns either
the first error or a list of successful values.

[source,motoko]
----
func mapResult<A, R, E>(xs : List<A>, f : A -> Result.Result<R, E>) : Result.Result<List<R>, E>
----

[[value.append]]
== append

Append the elements from one list to another list.

[source,motoko]
----
func append<T>(l : List<T>, m : List<T>) : List<T>
----

[[value.flatten]]
== flatten

Concatenate a list of lists.

In some languages, this operation is also known as a `list join`.

[source,motoko]
----
func flatten<T>(l : List<List<T>>) : List<T>
----

[[value.take]]
== take

Returns the first `n` elements of the given list.
If the given list has fewer than `n` elements, this function returns
a copy of the full input list.

[source,motoko]
----
func take<T>(l : List<T>, n : Nat) : List<T>
----

[[value.drop]]
== drop

Drop the first `n` elements from the given list.

[source,motoko]
----
func drop<T>(l : List<T>, n : Nat) : List<T>
----

[[value.foldLeft]]
== foldLeft

Fold the list left-to-right using the given function (`f`).

[source,motoko]
----
func foldLeft<T, S>(l : List<T>, a : S, f : (S, T) -> S) : S
----

[[value.foldRight]]
== foldRight

Fold the list right-to-left using the given function (`f`).

[source,motoko]
----
func foldRight<T, S>(l : List<T>, a : S, f : (T, S) -> S) : S
----

[[value.find]]
== find

Return the first element for which the given predicate `f` is true,
if such an element exists.

[source,motoko]
----
func find<T>(l : List<T>, f : T -> Bool) : ?T
----

[[value.some]]
== some

Return true if there exists a list element for which
the given predicate `f` is true.

[source,motoko]
----
func some<T>(l : List<T>, f : T -> Bool) : Bool
----

[[value.all]]
== all

Return true if the given predicate `f` is true for all list
elements.

[source,motoko]
----
func all<T>(l : List<T>, f : T -> Bool) : Bool
----

[[value.merge]]
== merge

Merge two ordered lists into a single ordered list.
This function requires both list to be ordered as specified
by the given relation `lte`.

[source,motoko]
----
func merge<T>(l1 : List<T>, l2 : List<T>, lte : (T, T) -> Bool) : List<T>
----

[[value.compare]]
== compare

Compare two lists using lexicographic ordering specified by the given relation `lte`.

[source,motoko]
----
func compare<T>(l1 : List<T>, l2 : List<T>, compElm : (T, T) -> Order.Order) : Order.Order
----

[[value.equal]]
== equal

Compare two lists for equality as specified by the given relation `eq` on the elements.

The function `isEq(l1, l2)` is equivalent to `lessThanEq(l1,l2) && lessThanEq(l2,l1)`,
but the former is more efficient.

[source,motoko]
----
func equal<T>(l1 : List<T>, l2 : List<T>, eq : (T, T) -> Bool) : Bool
----

[[value.tabulate]]
== tabulate

Generate a list based on a length and a function that maps from
a list index to a list element.

[source,motoko]
----
func tabulate<T>(n : Nat, f : Nat -> T) : List<T>
----

[[value.make]]
== make

Create a list with exactly one element.

[source,motoko]
----
func make<X>(x : X) : List<X>
----

[[value.replicate]]
== replicate

Create a list of the given length with the same value in each position.

[source,motoko]
----
func replicate<X>(n : Nat, x : X) : List<X>
----

[[value.zip]]
== zip

Create a list of pairs from a pair of lists.

If the given lists have different lengths, then the created list will have a
length equal to the length of the smaller list.

[source,motoko]
----
func zip<X, Y>(xs : List<X>, ys : List<Y>) : List<(X, Y)>
----

[[value.zipWith]]
== zipWith

Create a list in which elements are calculated from the function `f` and
include elements occuring at the same position in the given lists.

If the given lists have different lengths, then the created list will have a
length equal to the length of the smaller list.

[source,motoko]
----
func zipWith<X, Y, Z>(xs : List<X>, ys : List<Y>, f : (X, Y) -> Z) : List<Z>
----

[[value.split]]
== split

Split the given list at the given zero-based index.

[source,motoko]
----
func split<X>(n : Nat, xs : List<X>) : (List<X>, List<X>)
----

[[value.chunks]]
== chunks

Split the given list into chunks of length `n`.
The last chunk will be shorter if the length of the given list
does not divide by `n` evenly.

[source,motoko]
----
func chunks<X>(n : Nat, xs : List<X>) : List<List<X>>
----

[[value.fromArray]]
== fromArray

Convert an array into a list.

[source,motoko]
----
func fromArray<A>(xs : [A]) : List<A>
----

[[value.fromVarArray]]
== fromVarArray

Convert a mutable array into a list.

[source,motoko]
----
func fromVarArray<A>(xs : [var A]) : List<A>
----

[[value.toArray]]
== toArray

Create an array from a list.

[source,motoko]
----
func toArray<A>(xs : List<A>) : [A]
----

[[value.toVarArray]]
== toVarArray

Create a mutable array from a list.

[source,motoko]
----
func toVarArray<A>(xs : List<A>) : [var A]
----

