[[module.Result]]
= Result

Error handling with the Result type.

[[type.Result]]
== Result

`Result<Ok, Err>` is the type used for returning and propagating errors. It
is a type with the variants, `#ok(Ok)`, representing success and containing
a value, and `#err(Err)`, representing error and containing an error value.

The simplest way of working with `Result`s is to pattern match on them:

For example, given a function `createUser(user : User) : Result<Id, String>`
where `String` is an error message we could use it like so:
```motoko
switch(createUser(myUser)) {
  case #ok(id) Debug.print("Created new user with id: " # id)
  case #err(msg) Debug.print("Failed to create user with the error: " # msg)
}
```

[source,motoko]
----
type Result<Ok, Err> = {#ok : Ok; #err : Err}
----

[[value.chain]]
== chain

Allows sequencing of `Result` values and functions that return
`Result`'s themselves.
```
func largerThan10(x : Nat) : Result<Nat, Text> =
  if (x > 10) { #ok(x) } else { #err("Not larger than 10.") };

func smallerThan20(x : Nat) : Result<Nat, Text> =
  if (x < 20) { #ok(x) } else { #err("Not smaller than 20.") };

func between10And20(x : Nat) : Result<Nat, Text> =
  chain(largerThan10(x), smallerThan20)

between10And20(15) = #ok(15);
between10And20(9) = #err("Not larger than 10.");
between10And20(21) = #err("Not smaller than 20.");
```

[source,motoko]
----
func chain<R1, R2, Error>(x : Result<R1, Error>, y : R1 -> Result<R2, Error>) : Result<R2, Error>
----

[[value.mapOk]]
== mapOk

Maps the `Ok` type/value, leaving any `Error` type/value unchanged.

[source,motoko]
----
func mapOk<Ok1, Ok2, Error>(x : Result<Ok1, Error>, f : Ok1 -> Ok2) : Result<Ok2, Error>
----

[[value.mapErr]]
== mapErr

Maps the `Err` type/value, leaving any `Ok` type/value unchanged.

[source,motoko]
----
func mapErr<Ok, Error1, Error2>(x : Result<Ok, Error1>, f : Error1 -> Error2) : Result<Ok, Error2>
----

[[value.fromOption]]
== fromOption

Create a result from an option, including an error value to handle the `null` case.
```
fromOption(?(x), e) = #ok(x)
fromOption(null, e) = #err(e)
```

[source,motoko]
----
func fromOption<R, E>(x : ?R, err : E) : Result<R, E>
----

[[value.fromSomeMap]]
== fromSomeMap

Maps the `Ok` type/value from the optional value, or else use the given error value.
(Deprecate?)

[source,motoko]
----
func fromSomeMap<R1, R2, E>(x : ?R1, f : R1 -> R2, err : E) : Result<R2, E>
----

[[value.fromSome]]
== fromSome

asserts that the option is Some(_) form.

[source,motoko]
----
func fromSome<Ok>(o : ?Ok) : Result<Ok, None>
----

[[value.toArrayOk]]
== toArrayOk

a result that consists of an array of Ok results from an array of results, or the first error in the result array, if any.

[source,motoko]
----
func toArrayOk<R, E>(x : [Result<R, E>]) : Result<[R], E>
----

[[value.unwrapOk]]
== unwrapOk

Extract and return the value `v` of an `#ok v` result.
Traps if its argument is an `#err` result.
Recommended for testing only, not for production code.

[source,motoko]
----
func unwrapOk<Ok, Error>(r : Result<Ok, Error>) : Ok
----

[[value.unwrapErr]]
== unwrapErr

Extract and return the value `v` of an `#err v` result.
Traps if its argument is an `#ok` result.
Recommended for testing only, not for production code.

[source,motoko]
----
func unwrapErr<Ok, Error>(r : Result<Ok, Error>) : Error
----

[[value.assertOk]]
== assertOk

Asserts that its argument is an `#ok` result, traps otherwise.

[source,motoko]
----
func assertOk(r : Result<Any, Any>)
----

[[value.assertErr]]
== assertErr

Asserts that its argument is an `#err` result, traps otherwise.

[source,motoko]
----
func assertErr(r : Result<Any, Any>)
----

