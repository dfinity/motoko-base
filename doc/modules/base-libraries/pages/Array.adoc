[[module.Array]]
= Array

Functions on Arrays

[[value.equal]]
== equal

Test if two arrays contain equal values

[source,motoko]
----
func equal<A>(a : [A], b : [A], eq : (A, A) -> Bool) : Bool
----

[[value.append]]
== append

Append the values of two input arrays

[source,motoko]
----
func append<A>(xs : [A], ys : [A]) : [A]
----

[[value.chain]]
== chain

Transform each array value into zero or more output values, appended in order

[source,motoko]
----
func chain<A, B>(xs : [A], f : A -> [B]) : [B]
----

[[value.filter]]
== filter

Output array contains each array-value if and only if the predicate is true; ordering retained.

[source,motoko]
----
func filter<A>(xs : [A], f : A -> Bool) : [A]
----

[[value.mapFilter]]
== mapFilter

Output array contains each transformed optional value; ordering retained.

[source,motoko]
----
func mapFilter<A, B>(xs : [A], f : A -> ?B) : [B]
----

[[value.foldLeft]]
== foldLeft

Aggregate and transform values into a single output value, by increasing indices.

[source,motoko]
----
func foldLeft<A, B>(xs : [A], initial : B, f : (B, A) -> B) : B
----

[[value.foldRight]]
== foldRight

Aggregate and transform values into a single output value, by decreasing indices.

[source,motoko]
----
func foldRight<A, B>(xs : [A], initial : B, f : (A, B) -> B) : B
----

[[value.find]]
== find

Returns optional first value for which predicate is true

[source,motoko]
----
func find<A>(xs : [A], f : A -> Bool) : ?A
----

[[value.freeze]]
== freeze

Transform mutable array into immutable array

[source,motoko]
----
func freeze<A>(xs : [var A]) : [A]
----

[[value.flatten]]
== flatten

Transform an array of arrays into a single array, with retained array-value order.

[source,motoko]
----
func flatten<A>(xs : [[A]]) : [A]
----

[[value.map]]
== map

Transform each value using a function, with retained array-value order.

[source,motoko]
----
func map<A, B>(xs : [A], f : A -> B) : [B]
----

[[value.mapEntries]]
== mapEntries

Transform each entry (index-value pair) using a function.

[source,motoko]
----
func mapEntries<A, B>(xs : [A], f : (A, Nat) -> B) : [B]
----

[[value.mapResult]]
== mapResult

Maps a Result-returning function over an Array and returns either
the first error or an array of successful values.

```motoko
func makeNatural(x : Int) : Result.Result<Nat, Text> =
  if (x >= 0) {
    #ok(Int.abs(x))
  } else {
    #err(Int.toText(x) # " is not a natural number.")
  };

mapResult([0, 1, 2], makeNatural) = #ok([0, 1, 2]);
mapResult([-1, 0, 1], makeNatural) = #err("-1 is not a natural number.");
```

[source,motoko]
----
func mapResult<A, R, E>(xs : [A], f : A -> Result.Result<R, E>) : Result.Result<[R], E>
----

[[value.make]]
== make

Make an array from a single value.

[source,motoko]
----
func make<A>(x : A) : [A]
----

[[value.vals]]
== vals

Returns `xs.vals()`.

[source,motoko]
----
func vals<A>(xs : [A]) : I.Iter<A>
----

[[value.keys]]
== keys

Returns `xs.keys()`.

[source,motoko]
----
func keys<A>(xs : [A]) : I.Iter<Nat>
----

[[value.thaw]]
== thaw

Transform an immutable array into a mutable array.

[source,motoko]
----
func thaw<A>(xs : [A]) : [var A]
----

[[value.init]]
== init

Initialize a mutable array with `size` copies of the initial value.

[source,motoko]
----
func init<A>(size : Nat, initVal : A) : [var A]
----

[[value.tabulate]]
== tabulate

Initialize a mutable array of the given size, and use the `gen` function to produce the initial value for every index.

[source,motoko]
----
func tabulate<A>(size : Nat, gen : Nat -> A) : [A]
----

[[value.tabulateVar]]
== tabulateVar

Initialize a mutable array using a generation function

[source,motoko]
----
func tabulateVar<A>(size : Nat, gen : Nat -> A) : [var A]
----

