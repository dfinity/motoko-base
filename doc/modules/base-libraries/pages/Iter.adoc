[[module.Iter]]
= Iter

Iterators

[[type.Iter]]
== Iter

An iterator that produces values of type `T`. Calling `next` returns
`null` when iteration is finished.

Iterators are inherently stateful. Calling `next` "consumes" a value from
the Iterator that cannot be put back, so keep that in mind when sharing
iterators between consumers.

An iterater `i` can be iterated over using
```
for (x in i) {
  …do something with x…
}
```

[source,motoko]
----
type Iter<T> = { next : () -> ?T }
----

[[class.range]]
== range

Creates an iterator that produces all `Nat`'s from `x` to `y` including
both of the bounds.
```
let iter = range(1, 3);
assertEqual(?1, iter.next());
assertEqual(?2, iter.next());
assertEqual(?3, iter.next());
assertEqual(null, iter.next());
```

[source,motoko]
----
class range(x : Nat, y : Int)
----



[[Rangevalue.next]]
=== next



[source,motoko]
----
func next() : ?Nat
----

[[class.revRange]]
== revRange

Like [`range`](#value.range) but produces the values in the opposite
order.

[source,motoko]
----
class revRange(x : Int, y : Int)
----



[[revRangevalue.next]]
=== next



[source,motoko]
----
func next() : ?Int
----

[[value.iterate]]
== iterate

Calls a function `f` on every value produced by an iterator and discards
the results. If you're looking to keep these results use
[`map`](#value.map).
```
var sum = 0;
iterate(range(1, 3), func(x : Nat) {
  sum += x;
});
assertEquals(6, sum)
```

[source,motoko]
----
func iterate<A>(xs : Iter<A>, f : (A, Nat) -> ())
----

[[value.size]]
== size

Consumes an iterator and counts how many elements were produced
(discarding them in the process).

[source,motoko]
----
func size<A>(xs : Iter<A>) : Nat
----

[[value.map]]
== map

Takes a function and an iterator and returns a new iterator that lazily applies
the function to every element produced by the argument iterator.
```
let iter = range(1, 3);
let mappedIter = map(iter, func (x : Nat) : Nat { x * 2 });
assertEqual(?2, mappedIter.next());
assertEqual(?4, mappedIter.next());
assertEqual(?6, mappedIter.next());
assertEqual(null, mappedIter.next());
```

[source,motoko]
----
func map<A, B>(xs : Iter<A>, f : A -> B) : Iter<B>
----

[[value.make]]
== make

Creates an iterator that produces an infinite sequence of `x`.
```
let iter = make(10);
assertEquals(?10, iter.next())
assertEquals(?10, iter.next())
assertEquals(?10, iter.next())
// ...
```

[source,motoko]
----
func make<A>(x : A) : Iter<A>
----

[[value.fromArray]]
== fromArray

Creates an iterator that produces the elements of an Array in ascending index order.
```
let iter = fromArray([1, 2, 3]);
assertEquals(?1, iter.next())
assertEquals(?2, iter.next())
assertEquals(?3, iter.next())
assertEquals(null, iter.next())
```

[source,motoko]
----
func fromArray<A>(xs : [A]) : Iter<A>
----

[[value.fromArrayMut]]
== fromArrayMut

Like [`fromArray`](#value.fromArray) but for Arrays with mutable elements.
Captures the elements of the Array at the time the iterator is created, so
further modifications won't be reflected in the iterator.

[source,motoko]
----
func fromArrayMut<A>(xs : [var A]) : Iter<A>
----

[[value.fromList]]
== fromList

Like [`fromArray`](#value.fromArray) but for Lists.

[source,motoko]
----
func fromList<A>(xs : List.List<A>) : Iter<A>
----

[[value.toArray]]
== toArray

Consumes an iterator and collects its produced elements in an Array.
```
let iter = range(1, 3);
assertEquals([1, 2, 3], toArray(iter));
```

[source,motoko]
----
func toArray<A>(xs : Iter<A>) : [A]
----

[[value.toArrayMut]]
== toArrayMut

Like [`toArray`](#value.toArray) but for Arrays with mutable elements.

[source,motoko]
----
func toArrayMut<A>(xs : Iter<A>) : [var A]
----

[[value.toList]]
== toList

Like [`toArray`](#value.toArray) but for Lists.

[source,motoko]
----
func toList<A>(xs : Iter<A>) : List.List<A>
----

