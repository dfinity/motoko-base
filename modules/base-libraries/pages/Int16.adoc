[[module.Int16]]
= Int16

16-bit signed integers with checked arithmetic.

Common 16-bit integer functions.
Most operations are available as built-in operators (e.g. `1 + 1`).

[[type.Int16]]
== Int16

[source.no-repl,motoko,subs=+macros]
----
type Int16 = Prim.Types.Int16
----

16-bit signed integers.

[[minimumValue]]
== minimumValue

[source.no-repl,motoko,subs=+macros]
----
let minimumValue : xref:#type.Int16[Int16]
----

Minimum 16-bit integer value, `-2 ** 15`.

[[maximumValue]]
== maximumValue

[source.no-repl,motoko,subs=+macros]
----
let maximumValue : xref:#type.Int16[Int16]
----

Maximum 16-bit integer value, `+2 ** 15 - 1`.

[[toInt]]
== toInt

[source.no-repl,motoko,subs=+macros]
----
let toInt : xref:#type.Int16[Int16] -> Int
----

Converts a 16-bit signed integer to a signed integer with infinite precision.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.toInt(12_345) // => 12_345 : Int
```

[[fromInt]]
== fromInt

[source.no-repl,motoko,subs=+macros]
----
let fromInt : Int -> xref:#type.Int16[Int16]
----

Converts a signed integer with infinite precision to a 16-bit signed integer.

Traps on overflow/underflow.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.fromInt(12_345) // => +12_345 : Int16
```

[[fromIntWrap]]
== fromIntWrap

[source.no-repl,motoko,subs=+macros]
----
let fromIntWrap : Int -> xref:#type.Int16[Int16]
----

Converts a signed integer with infinite precision to a 16-bit signed integer.

Wraps on overflow/underflow.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.fromIntWrap(-12_345) // => -12_345 : Int
```

[[fromNat16]]
== fromNat16

[source.no-repl,motoko,subs=+macros]
----
let fromNat16 : Nat16 -> xref:#type.Int16[Int16]
----

Converts an unsigned 16-bit integer to a signed 16-bit integer.

Wraps on overflow/underflow.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.fromNat16(12_345) // => +12_345 : Int16
```

[[toNat16]]
== toNat16

[source.no-repl,motoko,subs=+macros]
----
let toNat16 : xref:#type.Int16[Int16] -> Nat16
----

Converts a signed 16-bit integer to an unsigned 16-bit integer.

Wraps on overflow/underflow.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.toNat16(-1) // => 65_535 : Nat16 // underflow
```

[[toText]]
== toText

[source.no-repl,motoko,subs=+macros]
----
func toText(x : xref:#type.Int16[Int16]) : Text
----

Returns the Text representation of `x`.
Formats the integer in decimal representation without underscore separators for thousand figures.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.toText(-12345) // => "-12345"
```

[[abs]]
== abs

[source.no-repl,motoko,subs=+macros]
----
func abs(x : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the absolute value of `x`.

Traps when `x == -2 ** 15` (the minimum `Int16` value).

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.abs(-12345) // => +12_345
```

[[min]]
== min

[source.no-repl,motoko,subs=+macros]
----
func min(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the minimum of `x` and `y`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.min(+2, -3) // => -3
```

[[max]]
== max

[source.no-repl,motoko,subs=+macros]
----
func max(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the maximum of `x` and `y`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.max(+2, -3) // => +2
```

[[equal]]
== equal

[source.no-repl,motoko,subs=+macros]
----
func equal(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : Bool
----

Returns `x == y`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.equal(123, 123) // => true
```

[[notEqual]]
== notEqual

[source.no-repl,motoko,subs=+macros]
----
func notEqual(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : Bool
----

Returns `x != y`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.notEqual(123, 123) // => false
```

[[less]]
== less

[source.no-repl,motoko,subs=+macros]
----
func less(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : Bool
----

Returns `x < y`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.less(123, 1234) // => true
```

[[lessOrEqual]]
== lessOrEqual

[source.no-repl,motoko,subs=+macros]
----
func lessOrEqual(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : Bool
----

Returns `x <= y`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.lessOrEqual(123, 1234) // => true
```

[[greater]]
== greater

[source.no-repl,motoko,subs=+macros]
----
func greater(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : Bool
----

Returns `x > y`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.greater(1234, 123) // => true
```

[[greaterOrEqual]]
== greaterOrEqual

[source.no-repl,motoko,subs=+macros]
----
func greaterOrEqual(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : Bool
----

Returns `x >= y`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.greaterOrEqual(1234, 123) // => true
```

[[compare]]
== compare

[source.no-repl,motoko,subs=+macros]
----
func compare(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : {#less; #equal; #greater}
----

Returns the order of `x` and `y`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.compare(123, 1234) // => #less
```

[[neg]]
== neg

[source.no-repl,motoko,subs=+macros]
----
func neg(x : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the negation of `x`, `-x`.

Traps on overflow, i.e. for `neg(-2 ** 15)`.


Example:
```motoko
import Int16 "mo:base/Int16";

Int16.neg(123) // => -123
```

[[add]]
== add

[source.no-repl,motoko,subs=+macros]
----
func add(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the sum of `x` and `y`, `x + y`.

Traps on overflow/underflow.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.add(1234, 123) // => +1_357
```

[[sub]]
== sub

[source.no-repl,motoko,subs=+macros]
----
func sub(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the difference of `x` and `y`, `x - y`.

Traps on overflow/underflow.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.sub(1234, 123) // => +1_111
```

[[mul]]
== mul

[source.no-repl,motoko,subs=+macros]
----
func mul(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the product of `x` and `y`, `x * y`.

Traps on overflow/underflow.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.mul(123, 100) // => +12_300
```

[[div]]
== div

[source.no-repl,motoko,subs=+macros]
----
func div(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the signed integer division of `x` by `y`, `x / y`.
Rounds the quotient towards zero, which is the same as truncating the decimal places of the quotient.

Traps when `y` is zero.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.div(123, 10) // => +12
```

[[rem]]
== rem

[source.no-repl,motoko,subs=+macros]
----
func rem(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the remainder of the signed integer division of `x` by `y`, `x % y`,
which is defined as `x - x / y * y`.

Traps when `y` is zero.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.rem(123, 10) // => +3
```

[[pow]]
== pow

[source.no-repl,motoko,subs=+macros]
----
func pow(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns `x` to the power of `y`, `x ** y`.

Traps on overflow/underflow and when `y < 0 or y >= 16`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.pow(2, 10) // => +1_024
```

[[bitnot]]
== bitnot

[source.no-repl,motoko,subs=+macros]
----
func bitnot(x : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the bitwise negation of `x`, `^x`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.bitnot(-256 /* 0xff00 */) // => +255 // 0xff
```

[[bitand]]
== bitand

[source.no-repl,motoko,subs=+macros]
----
func bitand(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the bitwise "and" of `x` and `y`, `x & y`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.bitand(0x0fff, 0x00f0) // => +240 // 0xf0
```

[[bitor]]
== bitor

[source.no-repl,motoko,subs=+macros]
----
func bitor(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the bitwise "or" of `x` and `y`, `x | y`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.bitor(0x0f0f, 0x00f0) // => +4_095 // 0x0fff
```

[[bitxor]]
== bitxor

[source.no-repl,motoko,subs=+macros]
----
func bitxor(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the bitwise "exclusive or" of `x` and `y`, `x ^ y`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.bitxor(0x0fff, 0x00f0) // => +3_855 // 0x0f0f
```

[[bitshiftLeft]]
== bitshiftLeft

[source.no-repl,motoko,subs=+macros]
----
func bitshiftLeft(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the bitwise left shift of `x` by `y`, `x << y`.
The right bits of the shift filled with zeros.
Left-overflowing bits, including the sign bit, are discarded.

For `y >= 16`, the semantics is the same as for `bitshiftLeft(x, y % 16)`.
For `y < 0`,  the semantics is the same as for `bitshiftLeft(x, y + y % 16)`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.bitshiftLeft(1, 8) // => +256 // 0x100 equivalent to `2 ** 8`.
```

[[bitshiftRight]]
== bitshiftRight

[source.no-repl,motoko,subs=+macros]
----
func bitshiftRight(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the signed bitwise right shift of `x` by `y`, `x >> y`.
The sign bit is retained and the left side is filled with the sign bit.
Right-underflowing bits are discarded, i.e. not rotated to the left side.

For `y >= 16`, the semantics is the same as for `bitshiftRight(x, y % 16)`.
For `y < 0`,  the semantics is the same as for `bitshiftRight (x, y + y % 16)`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.bitshiftRight(1024, 8) // => +4 // equivalent to `1024 / (2 ** 8)`
```

[[bitrotLeft]]
== bitrotLeft

[source.no-repl,motoko,subs=+macros]
----
func bitrotLeft(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the bitwise left rotatation of `x` by `y`, `x <<> y`.
Each left-overflowing bit is inserted again on the right side.
The sign bit is rotated like other bits, i.e. the rotation interprets the number as unsigned.

Changes the direction of rotation for negative `y`.
For `y >= 16`, the semantics is the same as for `bitrotLeft(x, y % 16)`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.bitrotLeft(0x2001, 4) // => +18 // 0x12.
```

[[bitrotRight]]
== bitrotRight

[source.no-repl,motoko,subs=+macros]
----
func bitrotRight(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the bitwise right rotation of `x` by `y`, `x <>> y`.
Each right-underflowing bit is inserted again on the right side.
The sign bit is rotated like other bits, i.e. the rotation interprets the number as unsigned.

Changes the direction of rotation for negative `y`.
For `y >= 16`, the semantics is the same as for `bitrotRight(x, y % 16)`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.bitrotRight(0x2010, 8) // => +4_128 // 0x01020.
```

[[bittest]]
== bittest

[source.no-repl,motoko,subs=+macros]
----
func bittest(x : xref:#type.Int16[Int16], p : Nat) : Bool
----

Returns the value of bit `p` in `x`, `x & 2**p == 2**p`.
If `p >= 16`, the semantics is the same as for `bittest(x, p % 16)`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.bittest(128, 7) // => true
```

[[bitset]]
== bitset

[source.no-repl,motoko,subs=+macros]
----
func bitset(x : xref:#type.Int16[Int16], p : Nat) : xref:#type.Int16[Int16]
----

Returns the value of setting bit `p` in `x` to `1`.
If `p >= 16`, the semantics is the same as for `bitset(x, p % 16)`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.bitset(0, 7) // => +128
```

[[bitclear]]
== bitclear

[source.no-repl,motoko,subs=+macros]
----
func bitclear(x : xref:#type.Int16[Int16], p : Nat) : xref:#type.Int16[Int16]
----

Returns the value of clearing bit `p` in `x` to `0`.
If `p >= 16`, the semantics is the same as for `bitclear(x, p % 16)`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.bitclear(-1, 7) // => -129
```

[[bitflip]]
== bitflip

[source.no-repl,motoko,subs=+macros]
----
func bitflip(x : xref:#type.Int16[Int16], p : Nat) : xref:#type.Int16[Int16]
----

Returns the value of flipping bit `p` in `x`.
If `p >= 16`, the semantics is the same as for `bitclear(x, p % 16)`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.bitflip(255, 7) // => +127
```

[[bitcountNonZero]]
== bitcountNonZero

[source.no-repl,motoko,subs=+macros]
----
let bitcountNonZero : (x : xref:#type.Int16[Int16]) -> xref:#type.Int16[Int16]
----

Returns the count of non-zero bits in `x`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.bitcountNonZero(0xff) // => +8
```

[[bitcountLeadingZero]]
== bitcountLeadingZero

[source.no-repl,motoko,subs=+macros]
----
let bitcountLeadingZero : (x : xref:#type.Int16[Int16]) -> xref:#type.Int16[Int16]
----

Returns the count of leading zero bits in `x`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.bitcountLeadingZero(0x80) // => +8
```

[[bitcountTrailingZero]]
== bitcountTrailingZero

[source.no-repl,motoko,subs=+macros]
----
let bitcountTrailingZero : (x : xref:#type.Int16[Int16]) -> xref:#type.Int16[Int16]
----

Returns the count of trailing zero bits in `x`.

Example:
```motoko
import Int16 "mo:base/Int16";

Int16.bitcountTrailingZero(0x0100) // => +8
```

[[addWrap]]
== addWrap

[source.no-repl,motoko,subs=+macros]
----
func addWrap(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the sum of `x` and `y`, `x +% y`.

Wraps on overflow/underflow.


Example:
```motoko
import Int16 "mo:base/Int16";

Int16.addWrap(2 ** 14, 2 ** 14) // => -32_768 // overflow
```

[[subWrap]]
== subWrap

[source.no-repl,motoko,subs=+macros]
----
func subWrap(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the difference of `x` and `y`, `x -% y`.

Wraps on overflow/underflow.


Example:
```motoko
import Int16 "mo:base/Int16";

Int16.subWrap(-2 ** 15, 1) // => +32_767 // underflow
```

[[mulWrap]]
== mulWrap

[source.no-repl,motoko,subs=+macros]
----
func mulWrap(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns the product of `x` and `y`, `x *% y`. Wraps on overflow.

Wraps on overflow/underflow.


Example:
```motoko
import Int16 "mo:base/Int16";

Int16.mulWrap(2 ** 8, 2 ** 8) // => 0 // overflow
```

[[powWrap]]
== powWrap

[source.no-repl,motoko,subs=+macros]
----
func powWrap(x : xref:#type.Int16[Int16], y : xref:#type.Int16[Int16]) : xref:#type.Int16[Int16]
----

Returns `x` to the power of `y`, `x **% y`.

Wraps on overflow/underflow.
Traps if `y < 0 or y >= 16`.


Example:
```motoko
import Int16 "mo:base/Int16";

Int16.powWrap(2, 15) // => -32_768 // overflow
```

