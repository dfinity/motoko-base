[[module.List]]
= List

Purely-functional, singly-linked lists.
A list of type `List<T>` is either `null` or an optional pair of a value of type `T` and a tail, itself of type `List<T>`.

:::note Assumptions

Runtime and space complexity assumes that `equal`, and other functions execute in `O(1)` time and space.
:::

To use this library, import it using:

```motoko name=initialize
import List "mo:base/List";
```

[[type.List]]
== List

[source.no-repl,motoko,subs=+macros]
----
type List<T> = ?(T, xref:#type.List[List]<T>)
----



[[nil]]
== nil

[source.no-repl,motoko,subs=+macros]
----
func nil<T>() : xref:#type.List[List]<T>
----

Create an empty list.

Example:
```motoko include=initialize
List.nil<Nat>() // => null
```

| Runtime   | Space     |
|-----------|-----------|
| `O(1)` | `O(1)` |

[[isNil]]
== isNil

[source.no-repl,motoko,subs=+macros]
----
func isNil<T>(l : xref:#type.List[List]<T>) : Bool
----

Check whether a list is empty and return true if the list is empty.

Example:
```motoko include=initialize
List.isNil<Nat>(null) // => true
```

| Runtime   | Space     |
|-----------|-----------|
| `O(1)` | `O(1)` |

[[push]]
== push

[source.no-repl,motoko,subs=+macros]
----
func push<T>(x : T, l : xref:#type.List[List]<T>) : xref:#type.List[List]<T>
----

Add `x` to the head of `list`, and return the new list.

Example:
```motoko include=initialize
List.push<Nat>(0, null) // => ?(0, null);
```

| Runtime   | Space     |
|-----------|-----------|
| `O(1)` | `O(1)` |

[[last]]
== last

[source.no-repl,motoko,subs=+macros]
----
func last<T>(l : xref:#type.List[List]<T>) : ?T
----

Return the last element of the list, if present.
Example:
```motoko include=initialize
List.last<Nat>(?(0, ?(1, null))) // => ?1
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(1)` |

[[pop]]
== pop

[source.no-repl,motoko,subs=+macros]
----
func pop<T>(l : xref:#type.List[List]<T>) : (?T, xref:#type.List[List]<T>)
----

Remove the head of the list, returning the optioned head and the tail of the list in a pair.
Returns `(null, null)` if the list is empty.

Example:
```motoko include=initialize
List.pop<Nat>(?(0, ?(1, null))) // => (?0, ?(1, null))
```

| Runtime   | Space     |
|-----------|-----------|
| `O(1)` | `O(1)` |

[[size]]
== size

[source.no-repl,motoko,subs=+macros]
----
func size<T>(l : xref:#type.List[List]<T>) : Nat
----

Return the length of the list.

Example:
```motoko include=initialize
List.size<Nat>(?(0, ?(1, null))) // => 2
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(1)` |

[[get]]
== get

[source.no-repl,motoko,subs=+macros]
----
func get<T>(l : xref:#type.List[List]<T>, n : Nat) : ?T
----

Access any item in a list, zero-based.

:::note Consideration
Indexing into a list is a linear operation, and usually an
indication that a list might not be the best data structure
to use.
:::

Example:

```motoko include=initialize
List.get<Nat>(?(0, ?(1, null)), 1) // => ?1
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(1)` |

[[reverse]]
== reverse

[source.no-repl,motoko,subs=+macros]
----
func reverse<T>(l : xref:#type.List[List]<T>) : xref:#type.List[List]<T>
----

Reverses the list.

Example:
```motoko include=initialize
List.reverse<Nat>(?(0, ?(1, ?(2, null)))) // => ?(2, ?(1, ?(0, null)))
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(size)` |

[[iterate]]
== iterate

[source.no-repl,motoko,subs=+macros]
----
func iterate<T>(l : xref:#type.List[List]<T>, f : T -> ())
----

Call the given function for its side effect, with each list element in turn.

Example:
```motoko include=initialize
var sum = 0;
List.iterate<Nat>(?(0, ?(1, ?(2, null))), func n { sum += n });
sum // => 3
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(size)` |


[[map]]
== map

[source.no-repl,motoko,subs=+macros]
----
func map<T, U>(l : xref:#type.List[List]<T>, f : T -> U) : xref:#type.List[List]<U>
----

Call the given function `f` on each list element and collect the results
in a new list.

Example:
```motoko include=initialize
import Nat = "mo:base/Nat"
List.map<Nat, Text>(?(0, ?(1, ?(2, null))), Nat.toText) // => ?("0", ?("1", ?("2", null))
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(size)` |

[[filter]]
== filter

[source.no-repl,motoko,subs=+macros]
----
func filter<T>(l : xref:#type.List[List]<T>, f : T -> Bool) : xref:#type.List[List]<T>
----

Create a new list with only those elements of the original list for which
the given function (often called the _predicate_) returns true.

Example:
```motoko include=initialize
List.filter<Nat>(?(0, ?(1, ?(2, null))), func n { n != 1 }) // => ?(0, ?(2, null))
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(size)` |

[[partition]]
== partition

[source.no-repl,motoko,subs=+macros]
----
func partition<T>(l : xref:#type.List[List]<T>, f : T -> Bool) : (xref:#type.List[List]<T>, xref:#type.List[List]<T>)
----

Create two new lists from the results of a given function (`f`).
The first list only includes the elements for which the given
function `f` returns true and the second list only includes
the elements for which the function returns false.

Example:
```motoko include=initialize
List.partition<Nat>(?(0, ?(1, ?(2, null))), func n { n != 1 }) // => (?(0, ?(2, null)), ?(1, null))
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(size)` |


[[mapFilter]]
== mapFilter

[source.no-repl,motoko,subs=+macros]
----
func mapFilter<T, U>(l : xref:#type.List[List]<T>, f : T -> ?U) : xref:#type.List[List]<U>
----

Call the given function on each list element, and collect the non-null results
in a new list.

Example:
```motoko include=initialize
List.mapFilter<Nat, Nat>(
  ?(1, ?(2, ?(3, null))),
  func n {
    if (n > 1) {
      ?(n * 2);
    } else {
      null
    }
  }
) // => ?(4, ?(6, null))
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(size)` |


[[mapResult]]
== mapResult

[source.no-repl,motoko,subs=+macros]
----
func mapResult<T, R, E>(xs : xref:#type.List[List]<T>, f : T -> xref:Result.adoc#type.Result[Result.Result]<R, E>) : xref:Result.adoc#type.Result[Result.Result]<xref:#type.List[List]<R>, E>
----

Maps a Result-returning function `f` over a List and returns either
the first error or a list of successful values.

Example:
```motoko include=initialize
List.mapResult<Nat, Nat, Text>(
  ?(1, ?(2, ?(3, null))),
  func n {
    if (n > 0) {
      #ok(n * 2);
    } else {
      #err("Some element is zero")
    }
  }
); // => #ok ?(2, ?(4, ?(6, null))
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(size)` |


[[append]]
== append

[source.no-repl,motoko,subs=+macros]
----
func append<T>(l : xref:#type.List[List]<T>, m : xref:#type.List[List]<T>) : xref:#type.List[List]<T>
----

Append the elements from one list to another list.

Example:
```motoko include=initialize
List.append<Nat>(
  ?(0, ?(1, ?(2, null))),
  ?(3, ?(4, ?(5, null)))
) // => ?(0, ?(1, ?(2, ?(3, ?(4, ?(5, null))))))
```

| Runtime     | Space       |
|-------------|-------------|
| `O(size(l))`  | `O(size(l))`  |

[[flatten]]
== flatten

[source.no-repl,motoko,subs=+macros]
----
func flatten<T>(l : xref:#type.List[List]<xref:#type.List[List]<T>>) : xref:#type.List[List]<T>
----

Flatten, or concatenate, a list of lists as a list.

Example:
```motoko include=initialize
List.flatten<Nat>(
  ?(?(0, ?(1, ?(2, null))),
    ?(?(3, ?(4, ?(5, null))),
      null))
); // => ?(0, ?(1, ?(2, ?(3, ?(4, ?(5, null))))))
```

| Runtime     | Space       |
|-------------|-------------|
| `O(size*size)`  | `O(size*size)`  |

[[take]]
== take

[source.no-repl,motoko,subs=+macros]
----
func take<T>(l : xref:#type.List[List]<T>, n : Nat) : xref:#type.List[List]<T>
----

Returns the first `n` elements of the given list.
If the given list has fewer than `n` elements, this function returns
a copy of the full input list.

Example:
```motoko include=initialize
List.take<Nat>(
  ?(0, ?(1, ?(2, null))),
  2
); // => ?(0, ?(1, null))
```

| Runtime     | Space       |
|-------------|-------------|
| `O(n)`  | `O(n)`  |

[[drop]]
== drop

[source.no-repl,motoko,subs=+macros]
----
func drop<T>(l : xref:#type.List[List]<T>, n : Nat) : xref:#type.List[List]<T>
----

Drop the first `n` elements from the given list.

Example:
```motoko include=initialize
List.drop<Nat>(
  ?(0, ?(1, ?(2, null))),
  2
); // => ?(2, null)
```

| Runtime     | Space       |
|-------------|-------------|
| `O(n)`  | `O(1)`  |

[[foldLeft]]
== foldLeft

[source.no-repl,motoko,subs=+macros]
----
func foldLeft<T, S>(list : xref:#type.List[List]<T>, base : S, combine : (S, T) -> S) : S
----

Collapses the elements in `list` into a single value by starting with `base`
and progessively combining elements into `base` with `combine`. Iteration runs
left to right.

Example:
```motoko include=initialize
import Nat "mo:base/Nat";
List.foldLeft<Nat, Text>(
  ?(1, ?(2, ?(3, null))),
  "",
  func (acc, x) { acc # Nat.toText(x)}
) // => "123"
```

| Runtime        | Space (Heap) | Space (Stack) |
|----------------|--------------|----------------|
| `O(size(list))`  | `O(1)`         | `O(1)`    |


[[foldRight]]
== foldRight

[source.no-repl,motoko,subs=+macros]
----
func foldRight<T, S>(list : xref:#type.List[List]<T>, base : S, combine : (T, S) -> S) : S
----

Collapses the elements in `buffer` into a single value by starting with `base`
and progessively combining elements into `base` with `combine`. Iteration runs
right to left.

Example:
```motoko include=initialize
import Nat "mo:base/Nat";
List.foldRight<Nat, Text>(
  ?(1, ?(2, ?(3, null))),
  "",
  func (x, acc) { Nat.toText(x) # acc}
) // => "123"
```

| Runtime       | Space (Heap) | Space (Stack)     |
|---------------|--------------|-------------------|
| `O(size(list))` | `O(1)`         | `O(size(list))`  |


[[find]]
== find

[source.no-repl,motoko,subs=+macros]
----
func find<T>(l : xref:#type.List[List]<T>, f : T -> Bool) : ?T
----

Return the first element for which the given predicate `f` is true,
if such an element exists.

Example:
```motoko include=initialize
List.find<Nat>(
  ?(1, ?(2, ?(3, null))),
  func n { n > 1 }
); // => ?2
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(1)` |


[[some]]
== some

[source.no-repl,motoko,subs=+macros]
----
func some<T>(l : xref:#type.List[List]<T>, f : T -> Bool) : Bool
----

Return true if there exists a list element for which
the given predicate `f` is true.

Example:
```motoko include=initialize
List.some<Nat>(
  ?(1, ?(2, ?(3, null))),
  func n { n > 1 }
) // => true
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(1)` |


[[all]]
== all

[source.no-repl,motoko,subs=+macros]
----
func all<T>(l : xref:#type.List[List]<T>, f : T -> Bool) : Bool
----

Return true if the given predicate `f` is true for all list
elements.

Example:
```motoko include=initialize
List.all<Nat>(
  ?(1, ?(2, ?(3, null))),
  func n { n > 1 }
); // => false
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(1)` |


[[merge]]
== merge

[source.no-repl,motoko,subs=+macros]
----
func merge<T>(l1 : xref:#type.List[List]<T>, l2 : xref:#type.List[List]<T>, lessThanOrEqual : (T, T) -> Bool) : xref:#type.List[List]<T>
----

Merge two ordered lists into a single ordered list.
This function requires both list to be ordered as specified
by the given relation `lessThanOrEqual`.

Example:
```motoko include=initialize
List.merge<Nat>(
  ?(1, ?(2, ?(4, null))),
  ?(2, ?(4, ?(6, null))),
  func (n1, n2) { n1 <= n2 }
); // => ?(1, ?(2, ?(2, ?(4, ?(4, ?(6, null))))))),
```

| Runtime                    | Space                  |
|----------------------------|------------------------|
| `O(size(l1) + size(l2))`     | `O(size(l1) + size(l2))` |


[[compare]]
== compare

[source.no-repl,motoko,subs=+macros]
----
func compare<T>(l1 : xref:#type.List[List]<T>, l2 : xref:#type.List[List]<T>, compare : (T, T) -> xref:Order.adoc#type.Order[Order.Order]) : xref:Order.adoc#type.Order[Order.Order]
----

Compare two lists using lexicographic ordering specified by argument function `compare`.

Example:
```motoko include=initialize
import Nat "mo:base/Nat";

List.compare<Nat>(
  ?(1, ?(2, null)),
  ?(3, ?(4, null)),
  Nat.compare
) // => #less
```

| Runtime                    | Space                  |
|----------------------------|------------------------|
| `O(size(l1))`     | `O(1)` |


[[equal]]
== equal

[source.no-repl,motoko,subs=+macros]
----
func equal<T>(l1 : xref:#type.List[List]<T>, l2 : xref:#type.List[List]<T>, equal : (T, T) -> Bool) : Bool
----

Compare two lists for equality using the argument function `equal` to determine equality of their elements.

Example:
```motoko include=initialize
import Nat "mo:base/Nat";

List.equal<Nat>(
  ?(1, ?(2, null)),
  ?(3, ?(4, null)),
  Nat.equal
); // => false
```

| Runtime                    | Space                  |
|----------------------------|------------------------|
| `O(size(l1))`     | `O(1)` |


[[tabulate]]
== tabulate

[source.no-repl,motoko,subs=+macros]
----
func tabulate<T>(n : Nat, f : Nat -> T) : xref:#type.List[List]<T>
----

Generate a list based on a length and a function that maps from
a list index to a list element.

Example:
```motoko include=initialize
List.tabulate<Nat>(
  3,
  func n { n * 2 }
) // => ?(0, ?(2, (?4, null)))
```

| Runtime                    | Space                  |
|----------------------------|------------------------|
| `O(n)`     | `O(n)` |


[[make]]
== make

[source.no-repl,motoko,subs=+macros]
----
func make<T>(x : T) : xref:#type.List[List]<T>
----

Create a list with exactly one element.

Example:
```motoko include=initialize
List.make<Nat>(
  0
) // => ?(0, null)
```

| Runtime   | Space     |
|-----------|-----------|
| `O(1)` | `O(1)` |

[[replicate]]
== replicate

[source.no-repl,motoko,subs=+macros]
----
func replicate<T>(n : Nat, x : T) : xref:#type.List[List]<T>
----

Create a list of the given length with the same value in each position.

Example:
```motoko include=initialize
List.replicate<Nat>(
  3,
  0
) // => ?(0, ?(0, ?(0, null)))
```

| Runtime                    | Space                  |
|----------------------------|------------------------|
| `O(n)`     | `O(n)` |

[[zip]]
== zip

[source.no-repl,motoko,subs=+macros]
----
func zip<T, U>(xs : xref:#type.List[List]<T>, ys : xref:#type.List[List]<U>) : xref:#type.List[List]<(T, U)>
----

Create a list of pairs from a pair of lists.

If the given lists have different lengths, then the created list will have a
length equal to the length of the smaller list.

Example:
```motoko include=initialize
List.zip<Nat, Text>(
  ?(0, ?(1, ?(2, null))),
  ?("0", ?("1", null)),
) // => ?((0, "0"), ?((1, "1"), null))
```

| Runtime                    | Space                  |
|----------------------------|------------------------|
| `O(min(size(xs), size(ys)))`     | `O(min(size(xs), size(ys)))` |

[[zipWith]]
== zipWith

[source.no-repl,motoko,subs=+macros]
----
func zipWith<T, U, V>(xs : xref:#type.List[List]<T>, ys : xref:#type.List[List]<U>, f : (T, U) -> V) : xref:#type.List[List]<V>
----

Create a list in which elements are created by applying function `f` to each pair `(x, y)` of elements
occuring at the same position in list `xs` and list `ys`.

If the given lists have different lengths, then the created list will have a
length equal to the length of the smaller list.

Example:
```motoko include=initialize
import Nat = "mo:base/Nat";
import Char = "mo:base/Char";

List.zipWith<Nat, Char, Text>(
  ?(0, ?(1, ?(2, null))),
  ?('a', ?('b', null)),
  func (n, c) { Nat.toText(n) # Char.toText(c) }
) // => ?("0a", ?("1b", null))
```

| Runtime                    | Space                  |
|----------------------------|------------------------|
| `O(min(size(xs), size(ys)))`     | `O(min(size(xs), size(ys)))` |


[[split]]
== split

[source.no-repl,motoko,subs=+macros]
----
func split<T>(n : Nat, xs : xref:#type.List[List]<T>) : (xref:#type.List[List]<T>, xref:#type.List[List]<T>)
----

Split the given list at the given zero-based index.

Example:
```motoko include=initialize
List.split<Nat>(
  2,
  ?(0, ?(1, ?(2, null)))
) // => (?(0, ?(1, null)), ?(2, null))
```

| Runtime     | Space       |
|-------------|-------------|
| `O(n)`  | `O(n)`  |

[[chunks]]
== chunks

[source.no-repl,motoko,subs=+macros]
----
func chunks<T>(n : Nat, xs : xref:#type.List[List]<T>) : xref:#type.List[List]<xref:#type.List[List]<T>>
----

Split the given list into chunks of length `n`.
The last chunk will be shorter if the length of the given list
does not divide by `n` evenly.

Example:
```motoko include=initialize
List.chunks<Nat>(
  2,
  ?(0, ?(1, ?(2, ?(3, ?(4, null)))))
)
/* => ?(?(0, ?(1, null)),
        ?(?(2, ?(3, null)),
          ?(?(4, null),
            null)))
*/
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(size)` |

[[fromArray]]
== fromArray

[source.no-repl,motoko,subs=+macros]
----
func fromArray<T>(xs : pass:[[]Tpass:[]]) : xref:#type.List[List]<T>
----

Convert an array into a list.

Example:
```motoko include=initialize
List.fromArray<Nat>([ 0, 1, 2, 3, 4])
// =>  ?(0, ?(1, ?(2, ?(3, ?(4, null)))))
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(size)` |

[[fromVarArray]]
== fromVarArray

[source.no-repl,motoko,subs=+macros]
----
func fromVarArray<T>(xs : pass:[[]var Tpass:[]]) : xref:#type.List[List]<T>
----

Convert a mutable array into a list.

Example:
```motoko include=initialize
List.fromVarArray<Nat>([var 0, 1, 2, 3, 4])
// =>  ?(0, ?(1, ?(2, ?(3, ?(4, null)))))
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(size)` |

[[toArray]]
== toArray

[source.no-repl,motoko,subs=+macros]
----
func toArray<T>(xs : xref:#type.List[List]<T>) : pass:[[]Tpass:[]]
----

Create an array from a list.
Example:
```motoko include=initialize
List.toArray<Nat>(?(0, ?(1, ?(2, ?(3, ?(4, null))))))
// => [0, 1, 2, 3, 4]
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(size)` |

[[toVarArray]]
== toVarArray

[source.no-repl,motoko,subs=+macros]
----
func toVarArray<T>(xs : xref:#type.List[List]<T>) : pass:[[]var Tpass:[]]
----

Create a mutable array from a list.
Example:
```motoko include=initialize
List.toVarArray<Nat>(?(0, ?(1, ?(2, ?(3, ?(4, null))))))
// => [var 0, 1, 2, 3, 4]
```

| Runtime   | Space     |
|-----------|-----------|
| `O(size)` | `O(size)` |

[[toIter]]
== toIter

[source.no-repl,motoko,subs=+macros]
----
func toIter<T>(xs : xref:#type.List[List]<T>) : xref:IterType.adoc#type.Iter[Iter.Iter]<T>
----

Create an iterator from a list.
Example:
```motoko include=initialize
var sum = 0;
for (n in List.toIter<Nat>(?(0, ?(1, ?(2, ?(3, ?(4, null))))))) {
  sum += n;
};
sum
// => 10
```

| Runtime   | Space     |
|-----------|-----------|
| `O(1)` | `O(1)` |

